package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"os"
	"regexp"
	"slices"
	"strconv"
	"time"

	"github.com/FachschaftMathPhysInfo/pepp/server/auth"
	"github.com/FachschaftMathPhysInfo/pepp/server/email"
	"github.com/FachschaftMathPhysInfo/pepp/server/graph/model"
	"github.com/FachschaftMathPhysInfo/pepp/server/models"
	"github.com/FachschaftMathPhysInfo/pepp/server/utils"
	"github.com/gosimple/slug"
	hermes "github.com/matcornic/hermes/v2"
	log "github.com/sirupsen/logrus"
	"github.com/uptrace/bun"
)

// Points is the resolver for the points field.
func (r *answerResolver) Points(ctx context.Context, obj *models.Answer) (int, error) {
	return int(obj.Points), nil
}

// Score is the resolver for the score field.
func (r *applicationResolver) Score(ctx context.Context, obj *models.Application) (int, error) {
	return int(obj.Score), nil
}

// Responses is the resolver for the responses field.
func (r *applicationResolver) Responses(ctx context.Context, obj *models.Application) ([]*model.QuestionAnswersPair, error) {
	form, err := r.Query().Forms(ctx, []int{int(obj.EventID)})
	if err != nil {
		return nil, err
	}

	qas := []*model.QuestionAnswersPair{}

	for _, question := range form[0].Questions {
		var aqs []*models.ApplicationToQuestion
		if err := r.DB.NewSelect().
			Model(&aqs).
			Relation("Answer").
			Where(`"aq"."question_id" = ?`, question.ID).
			Scan(ctx); err != nil {
			return nil, err
		}

		avs := []*model.AnswerValuePair{}
		for _, answer := range aqs {
			av := &model.AnswerValuePair{
				Answer: answer.Answer,
				Value:  &answer.Value,
			}

			avs = append(avs, av)
		}

		qa := &model.QuestionAnswersPair{
			Question: question,
			Answers:  avs,
		}

		qas = append(qas, qa)
	}

	return qas, nil
}

// RoomsAvailable is the resolver for the roomsAvailable field.
func (r *eventResolver) RoomsAvailable(ctx context.Context, obj *models.Event) ([]*models.Room, error) {
	subq := r.DB.NewSelect().
		Model((*models.Tutorial)(nil)).
		ColumnExpr("1").
		Relation("Event").
		Where("t.event_id = ?", obj.ID).
		Where("t.room_number = r.number").
		Where("t.building_id = r.building_id").
		WhereGroup(" AND ", func(sq *bun.SelectQuery) *bun.SelectQuery {
			return sq.
				Where(`"event"."to" BETWEEN ? AND ?`, obj.From, obj.To).
				WhereOr(`"event"."from" BETWEEN ? AND ?`, obj.From, obj.To).
				WhereOr(`? BETWEEN "event"."from" AND "event"."to"`, obj.From).
				WhereOr(`? BETWEEN "event"."from" AND "event"."to"`, obj.To)
		})

	var rooms []*models.Room
	if err := r.DB.NewSelect().
		Model(&rooms).
		Relation("Building").
		Where("NOT EXISTS (?)", subq).
		Scan(ctx); err != nil {
		return nil, err
	}

	return rooms, nil
}

// Kind is the resolver for the kind field.
func (r *labelResolver) Kind(ctx context.Context, obj *models.Label) (model.LabelKind, error) {
	return model.LabelKind(obj.Kind), nil
}

// AddUser is the resolver for the addUser field.
func (r *mutationResolver) AddUser(ctx context.Context, user models.User) (string, error) {
	sessionID, err := auth.GenerateSessionID()
	if err != nil {
		return "", fmt.Errorf("error while generating sessionID for %s: %s", user.Mail, err)
	}

	user.SessionID = sessionID

	if user.Password != "" {
		passwordHash, err := auth.Hash(user.Password)
		if err != nil {
			return "", err
		}

		user.Password = passwordHash
	}

	if _, err := r.DB.NewInsert().
		Model(&user).
		Exec(ctx); err != nil {

		// check whether user is already registered without password
		// set password for this case
		var password string
		if err := r.DB.NewSelect().
			Table("users").
			Column("password").
			Where("mail = ?", user.Mail).
			Scan(ctx, &password); err != nil {
			return "", err
		}
		if password == "" {
			// user needs to reconfirm
			user.Confirmed = utils.BoolPtr(true)
			if _, err := r.UpdateUser(ctx, user, int(user.ID)); err != nil {
				return "", err
			}
		}
	}

	m := r.MailConfig.Confirmation

	hashedMail, err := auth.Hash(user.Mail)

	if err != nil {
		log.Errorf("failed to generate confirmation link on user with mail: %s. ", user.Mail)
		log.Error("to activate the user, manually hash the mail with your configured parameters")
		log.Error(err)
		return "", fmt.Errorf("error while generating confirmation link on user creation")
	}

	log.Printf("hash: %s", hashedMail)

	m.Actions[0].Button.Link = fmt.Sprintf("%s/confirm/%s",
		os.Getenv("PUBLIC_URL"), hashedMail)

	if err := email.Send(user, m, r.MailConfig); err != nil {
		log.Error("failed to send email: ", err)
	}

	return sessionID, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, user models.User, id int) (int, error) {
	if user.Password != "" {
		passwordHash, err := auth.Hash(user.Password)
		if err != nil {
			return 0, err
		}

		user.Password = passwordHash
	}

	var oldMail string
	if err := r.DB.NewSelect().
		Model((*models.User)(nil)).
		Where("id = ?", id).
		Column("mail").
		Scan(ctx, &oldMail); err != nil {
		return 0, err
	}

	if oldMail != user.Mail {
		user.Confirmed = utils.BoolPtr(false)
	}

	if _, err := r.DB.NewUpdate().
		Model(&user).
		OmitZero().
		Where("id = ?", id).
		Exec(ctx); err != nil {
		return 0, err
	}

	if oldMail != user.Mail {
		m := r.MailConfig.Confirmation

		m.Actions[0].Button.Link = fmt.Sprintf("%s/confirm/%s",
			os.Getenv("PUBLIC_URL"), user.SessionID)

		if err := email.Send(user, m, r.MailConfig); err != nil {
			log.Error("failed to send email: ", err)
		}
	}

	return int(user.ID), nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id []int) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.User)(nil)).
		Where("id IN (?)", bun.In(id)).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), nil
}

// AddEvent is the resolver for the addEvent field.
func (r *mutationResolver) AddEvent(ctx context.Context, event []*models.Event) ([]int, error) {
	if _, err := r.DB.NewInsert().
		Model(&event).
		Exec(ctx); err != nil {
		return nil, err
	}

	var ids []int
	for _, e := range event {
		ids = append(ids, int(e.ID))
	}

	return ids, nil
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, id int, event models.Event) (int, error) {
	event.ID = int32(id)
	if _, err := r.DB.NewUpdate().
		Model(&event).
		OmitZero().
		WherePK().
		Exec(ctx); err != nil {
		return 0, err
	}

	return id, nil
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, id []int) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.Event)(nil)).
		Where("id IN (?)", bun.In(id)).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), nil
}

// AddTutorial is the resolver for the addTutorial field.
func (r *mutationResolver) AddTutorial(ctx context.Context, tutorial []*model.NewTutorial) ([]int, error) {
	var tutorials []*models.Tutorial
	for _, t := range tutorial {
		tutorials = append(tutorials, &models.Tutorial{EventID: int32(t.EventID), RoomNumber: t.RoomNumber, BuildingID: int32(t.BuildingID)})
	}

	if _, err := r.DB.NewInsert().
		Model(&tutorials).
		Exec(ctx); err != nil {
		return nil, err
	}

	var ids []int
	for i, t := range tutorials {
		ids = append(ids, int(t.ID))
		for _, userID := range tutorial[i].Tutors {
			if _, err := r.Mutation().AddTutorAssignmentForTutorial(ctx, models.TutorialToUserAssignment{TutorialID: t.ID, UserID: int32(userID)}); err != nil {
				return nil, err
			}
		}
	}

	return ids, nil
}

// UpdateTutorial is the resolver for the updateTutorial field.
func (r *mutationResolver) UpdateTutorial(ctx context.Context, id int, tutorial model.NewTutorial) (int, error) {
	t := models.Tutorial{EventID: int32(tutorial.EventID), RoomNumber: tutorial.RoomNumber, BuildingID: int32(tutorial.BuildingID), ID: int32(id)}
	if _, err := r.DB.NewUpdate().
		Model(&t).
		WherePK().
		Exec(ctx); err != nil {
		return 0, err
	}

	var oldTutorIDs []int32
	if err := r.DB.NewSelect().
		Model((*models.TutorialToUserAssignment)(nil)).
		Where("tutorial_id = ?", id).
		Column("user_id").
		Scan(ctx, &oldTutorIDs); err != nil {
		return 0, err
	}

	for _, tutorID := range tutorial.Tutors {
		if !slices.Contains(oldTutorIDs, int32(tutorID)) {
			_, err := r.Mutation().
				AddTutorAssignmentForTutorial(ctx,
					models.TutorialToUserAssignment{
						TutorialID: int32(id),
						UserID:     int32(tutorID),
					},
				)
			if err != nil {
				return 0, err
			}
		}
	}

	for _, oldTutorID := range oldTutorIDs {
		if !slices.Contains(tutorial.Tutors, int(oldTutorID)) {
			_, err := r.Mutation().
				DeleteTutorAssignmentForTutorial(ctx,
					models.TutorialToUserAssignment{
						TutorialID: int32(id),
						UserID:     oldTutorID,
					},
				)
			if err != nil {
				return 0, err
			}
		}
	}

	return int(t.ID), nil
}

// DeleteTutorial is the resolver for the deleteTutorial field.
func (r *mutationResolver) DeleteTutorial(ctx context.Context, id []int) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.Tutorial)(nil)).
		Where("id IN (?)", bun.In(id)).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), nil
}

// AddBuilding is the resolver for the addBuilding field.
func (r *mutationResolver) AddBuilding(ctx context.Context, building models.Building) (*models.Building, error) {
	if _, err := r.DB.NewInsert().
		Model(&building).
		Exec(ctx); err != nil {
		return nil, err
	}

	return &building, nil
}

// UpdateBuilding is the resolver for the updateBuilding field.
func (r *mutationResolver) UpdateBuilding(ctx context.Context, id int, building models.Building) (*models.Building, error) {
	if _, err := r.DB.NewUpdate().
		Model(&building).
		OmitZero().
		Where("id = ?", id).
		Exec(ctx); err != nil {
		return nil, err
	}

	updatedBuilding, err := r.Query().Buildings(ctx, []int{id})
	if err != nil {
		return nil, err
	}

	return updatedBuilding[0], nil
}

// DeleteBuilding is the resolver for the deleteBuilding field.
func (r *mutationResolver) DeleteBuilding(ctx context.Context, id []int) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.Building)(nil)).
		Where("id IN (?)", bun.In(id)).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), err
}

// AddRoom is the resolver for the addRoom field.
func (r *mutationResolver) AddRoom(ctx context.Context, room models.Room) (*models.Room, error) {
	if _, err := r.DB.NewInsert().
		Model(&room).
		Exec(ctx); err != nil {
		return nil, err
	}

	return &room, nil
}

// UpdateRoom is the resolver for the updateRoom field.
func (r *mutationResolver) UpdateRoom(ctx context.Context, room models.Room) (*models.Room, error) {
	if _, err := r.DB.NewUpdate().
		Model(&room).
		OmitZero().
		WherePK().
		Exec(ctx); err != nil {
		return nil, err
	}

	updatedRoom, err := r.Query().Rooms(ctx, []string{room.Number}, []int{int(room.BuildingID)})
	if err != nil {
		return nil, err
	}

	return updatedRoom[0], nil
}

// DeleteRoom is the resolver for the deleteRoom field.
func (r *mutationResolver) DeleteRoom(ctx context.Context, number []string, buildingID int) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.Room)(nil)).
		Where("number IN (?)", bun.In(number)).
		Where("building_id = ?", buildingID).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), nil
}

// AddLabel is the resolver for the addLabel field.
func (r *mutationResolver) AddLabel(ctx context.Context, label []*models.Label) ([]int, error) {
	for _, l := range label {
		if l.Color == "" {
			l.Color = "#D1D1D1"
		}
	}

	if _, err := r.DB.NewInsert().
		Model(&label).
		Exec(ctx); err != nil {
		return nil, err
	}

	var ids []int
	for _, l := range label {
		ids = append(ids, int(l.ID))
	}

	return ids, nil
}

// UpdateLabel is the resolver for the updateLabel field.
func (r *mutationResolver) UpdateLabel(ctx context.Context, id int, label models.Label) (int, error) {
	if _, err := r.DB.NewUpdate().
		Model(&label).
		Where("id = ?", id).
		OmitZero().
		Exec(ctx); err != nil {
		return 0, err
	}

	return id, nil
}

// DeleteLabel is the resolver for the deleteLabel field.
func (r *mutationResolver) DeleteLabel(ctx context.Context, id []int) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.Label)(nil)).
		Where("id IN (?)", bun.In(id)).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), err
}

// UpsertSetting is the resolver for the upsertSetting field.
func (r *mutationResolver) UpsertSetting(ctx context.Context, setting models.Setting) (string, error) {
	if setting.Type == model.ScalarTypeColor.String() {
		hexColorPattern := `^#(?:[0-9a-fA-F]{3,4}){1,2}$`
		if match, _ := regexp.MatchString(hexColorPattern, setting.Value); !match {
			return "", fmt.Errorf("unable to parse color: %s", setting.Value)
		}
	}

	if _, err := r.DB.NewInsert().
		Model(&setting).
		On("CONFLICT (key) DO UPDATE").
		Exec(ctx); err != nil {
		return "", err
	}

	if err := r.FetchSettings(ctx); err != nil {
		return "", err
	}

	return setting.Key, nil
}

// DeleteSetting is the resolver for the deleteSetting field.
func (r *mutationResolver) DeleteSetting(ctx context.Context, key []string) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.Setting)(nil)).
		Where("key = ?", key).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), nil
}

// AddForm is the resolver for the addForm field.
func (r *mutationResolver) AddForm(ctx context.Context, form models.Form) (*models.Form, error) {
	if _, err := r.DB.NewInsert().
		Model(&form).
		Exec(ctx); err != nil {
		return nil, err
	}

	return &form, nil
}

// UpdateForm is the resolver for the updateForm field.
func (r *mutationResolver) UpdateForm(ctx context.Context, id int, form models.Form) (*models.Form, error) {
	if _, err := r.DB.NewUpdate().
		Model(&form).
		Exec(ctx); err != nil {
		return nil, err
	}

	updatedForm, err := r.Query().Forms(ctx, []int{id})
	if err != nil {
		return nil, err
	}

	return updatedForm[0], nil
}

// DeleteForm is the resolver for the deleteForm field.
func (r *mutationResolver) DeleteForm(ctx context.Context, id []int) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.Form)(nil)).
		Where("id IN (?)", bun.In(id)).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), nil
}

// AddQuestion is the resolver for the addQuestion field.
func (r *mutationResolver) AddQuestion(ctx context.Context, question models.Question, answer []*models.Answer) (int, error) {
	if _, err := r.DB.NewInsert().
		Model(&question).
		Exec(ctx); err != nil {
		return 0, err
	}

	if _, err := r.Mutation().AddAnswer(ctx, int(question.ID), answer); err != nil {
		return 0, err
	}

	return int(question.ID), nil
}

// UpdateQuestion is the resolver for the updateQuestion field.
func (r *mutationResolver) UpdateQuestion(ctx context.Context, id int, question models.Question) (int, error) {
	if _, err := r.DB.NewUpdate().
		Model(&question).
		Where("id = ?", id).
		OmitZero().
		Exec(ctx); err != nil {
		return 0, err
	}

	return id, nil
}

// DeleteQuestion is the resolver for the deleteQuestion field.
func (r *mutationResolver) DeleteQuestion(ctx context.Context, id []int) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.Question)(nil)).
		Where("id IN (?)", id).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), nil
}

// AddAnswer is the resolver for the addAnswer field.
func (r *mutationResolver) AddAnswer(ctx context.Context, questionID int, answer []*models.Answer) (int, error) {
	for i, _ := range answer {
		answer[i].QuestionID = int32(questionID)
	}

	if _, err := r.DB.NewInsert().
		Model(&answer).
		Exec(ctx); err != nil {
		return 0, err
	}

	return len(answer), nil
}

// UpdateAnswer is the resolver for the updateAnswer field.
func (r *mutationResolver) UpdateAnswer(ctx context.Context, id int, answer models.Answer) (int, error) {
	if _, err := r.DB.NewUpdate().
		Model(&answer).
		Where("id = ?", id).
		OmitZero().
		Exec(ctx); err != nil {
		return 0, err
	}

	return id, nil
}

// DeleteAnswer is the resolver for the deleteAnswer field.
func (r *mutationResolver) DeleteAnswer(ctx context.Context, id []int) (int, error) {
	res, err := r.DB.NewDelete().
		Model((*models.Answer)(nil)).
		Where("id IN (?)", id).
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	return int(rowsAffected), nil
}

// AddTutorAssignmentForTutorial is the resolver for the addTutorAssignmentForTutorial field.
func (r *mutationResolver) AddTutorAssignmentForTutorial(ctx context.Context, assignment models.TutorialToUserAssignment) (int, error) {
	if _, err := r.DB.NewInsert().
		Model(&assignment).
		Exec(ctx); err != nil {
		return 0, err
	}

	tutorials, err := r.Query().Tutorials(ctx, []int{int(assignment.TutorialID)}, nil, nil, nil, nil)
	if err != nil {
		return 0, err
	}
	tutorial := tutorials[0]

	m := r.MailConfig.Assignment

	m.Subject = fmt.Sprintf("%s: %s",
		r.Settings["email-assignment-subject"], tutorial.Event.Title)

	roomNumber := tutorial.Room.Number
	if tutorial.Room.Name != "" {
		roomNumber = fmt.Sprintf("%s (%s)",
			tutorial.Room.Name, tutorial.Room.Number)
	}

	m.Dictionary = []hermes.Entry{
		{Key: r.Settings["email-assignment-event-title"],
			Value: tutorial.Event.Title},
		{Key: r.Settings["email-assignment-date-title"],
			Value: tutorial.Event.From.Format("02.01.2006")},
		{Key: r.Settings["email-assignment-time-title"],
			Value: fmt.Sprintf("%s - %s",
				tutorial.Event.From.Format("15:04"), tutorial.Event.To.Format("15:04"))},
		{Key: r.Settings["email-assignment-room-title"],
			Value: roomNumber},
		{Key: r.Settings["email-assignment-building-title"],
			Value: fmt.Sprintf("%s, %s %s, %s, %s",
				tutorial.Room.Building.Name,
				tutorial.Room.Building.Street, tutorial.Room.Building.Number,
				tutorial.Room.Building.Zip, tutorial.Room.Building.City)}}

	users, err := r.Query().Users(ctx, []int{int(assignment.UserID)}, nil)
	if err != nil {
		return 0, err
	}
	user := users[0]

	if err := email.Send(*user, m, r.MailConfig); err != nil {
		return 0, err
	}

	return int(assignment.UserID), nil
}

// DeleteTutorAssignmentForTutorial is the resolver for the deleteTutorAssignmentForTutorial field.
func (r *mutationResolver) DeleteTutorAssignmentForTutorial(ctx context.Context, assignment models.TutorialToUserAssignment) (int, error) {
	res, err := r.DB.NewDelete().
		Model(&assignment).
		WherePK().
		Exec(ctx)
	if err != nil {
		return 0, err
	}

	rowsAffected, _ := res.RowsAffected()
	if rowsAffected == 0 {
		return 0, fmt.Errorf("user was not assigned to this event")
	}

	return int(assignment.UserID), nil
}

// AddTutorAvailabilityForEvent is the resolver for the addTutorAvailabilityForEvent field.
func (r *mutationResolver) AddTutorAvailabilityForEvent(ctx context.Context, availability model.NewUserToEventAvailability) (*models.User, error) {
	availabilitys := []models.UserToEventAvailability{}
	for _, eID := range availability.EventID {
		a := models.UserToEventAvailability{
			UserID:  int32(availability.UserID),
			EventID: int32(eID),
		}

		availabilitys = append(availabilitys, a)
	}

	if _, err := r.DB.NewInsert().
		Model(&availabilitys).
		Exec(ctx); err != nil {
		return nil, err
	}

	if err := r.DB.NewSelect().
		Model(&availabilitys).
		Relation("Event").
		Relation("Event.Type").
		WherePK().
		Scan(ctx); err != nil {
		return nil, err
	}

	m := r.MailConfig.Availability

	m.Table.Data = *new([][]hermes.Entry)
	for _, a := range availabilitys {
		e := []hermes.Entry{
			{Key: r.Settings["email-assignment-event-title"], Value: a.Event.Title},
			{Key: r.Settings["email-assignment-date-title"], Value: a.Event.From.Format("02.01")},
			{Key: r.Settings["email-assignment-kind-title"], Value: a.Event.Type.Name}}
		m.Table.Data = append(m.Table.Data, e)
	}

	user, err := r.Query().Users(ctx, []int{int(availability.UserID)}, nil)
	if err != nil {
		return nil, err
	}

	if err := email.Send(*user[0], m, r.MailConfig); err != nil {
		return nil, err
	}

	return user[0], nil
}

// DeleteTutorAvailabilityForEvent is the resolver for the deleteTutorAvailabilityForEvent field.
func (r *mutationResolver) DeleteTutorAvailabilityForEvent(ctx context.Context, availability model.NewUserToEventAvailability) (*models.User, error) {
	if _, err := r.DB.NewDelete().
		Model((*models.UserToEventAvailability)(nil)).
		Where("user_id = ?", availability.UserID).
		Where("event_id IN (?)", bun.In(availability.EventID)).
		Exec(ctx); err != nil {
		return nil, err
	}

	user, err := r.Query().Users(ctx, []int{availability.UserID}, nil)
	if err != nil {
		return nil, err
	}

	return user[0], nil
}

// AddStudentRegistrationForTutorial is the resolver for the addStudentRegistrationForTutorial field.
func (r *mutationResolver) AddStudentRegistrationForTutorial(ctx context.Context, registration models.UserToTutorialRegistration) (int, error) {
	tutorial := new(models.Tutorial)
	if err := r.DB.NewSelect().
		Model(tutorial).
		Relation("Event").
		Relation("Room").
		Where("t.id = ?", registration.TutorialID).
		Scan(ctx); err != nil {
		return 0, err
	}

	if !*tutorial.Event.TutorialsOpen {
		return 0, fmt.Errorf("tutorial is not open for registrations, yet")
	}

	tutorialCapacity := tutorial.Room.Capacity
	registrationCount, err := r.DB.NewSelect().
		Model((*models.UserToTutorialRegistration)(nil)).
		Relation("Tutorial").
		Where("tutorial_id = ?", tutorial.ID).
		Count(ctx)
	if err != nil {
		return 0, err
	}

	if int(tutorialCapacity)-registrationCount <= 0 {
		return 0, fmt.Errorf("tutorial capacity exceeded")
	}

	formExists, err := r.DB.NewSelect().
		Model((*models.Form)(nil)).
		Where("event_id = ?", tutorial.Event.UmbrellaID).
		Exists(ctx)
	if err != nil {
		return 0, err
	}

	if formExists {
		var accepted *bool
		if err := r.DB.NewSelect().
			Model((*models.Application)(nil)).
			Where("student_id = ?", registration.UserID).
			Column("accepted").
			Scan(ctx, &accepted); err != nil {
			return 0, err
		}

		if accepted == nil || !*accepted {
			return 0, fmt.Errorf("student is not accepted for event")
		}
	}

	count, err := r.DB.NewSelect().
		Model((*models.UserToTutorialRegistration)(nil)).
		Relation("Tutorial").
		Where("user_id = ?", registration.UserID).
		Where("tutorial.event_id = ?", tutorial.EventID).
		Count(ctx)
	if err != nil {
		return 0, err
	}

	if count != 0 {
		return 0, fmt.Errorf("student is not allowed to be registered in multiple tutorials in one event")
	}

	if _, err := r.DB.NewInsert().
		Model(&registration).
		Exec(ctx); err != nil {
		return 0, err
	}

	return int(registration.UserID), nil
}

// DeleteStudentRegistrationForTutorial is the resolver for the deleteStudentRegistrationForTutorial field.
func (r *mutationResolver) DeleteStudentRegistrationForTutorial(ctx context.Context, registration models.UserToTutorialRegistration) (int, error) {
	if _, err := r.DB.NewDelete().
		Model(&registration).
		WherePK().
		Exec(ctx); err != nil {
		return 0, err
	}

	return int(registration.UserID), nil
}

// AddStudentApplicationForEvent is the resolver for the addStudentApplicationForEvent field.
func (r *mutationResolver) AddStudentApplicationForEvent(ctx context.Context, application model.NewUserToEventApplication) (*models.User, error) {
	exists, err := r.DB.NewSelect().
		Model((*models.Application)(nil)).
		Where("event_id = ? AND student_id = ?", application.EventID, application.UserID).
		Exists(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to check for existing application")
	}
	if exists {
		return nil, fmt.Errorf("application already exists for event and student pairing")
	}

	score := 0

	aqs := []models.ApplicationToQuestion{}
	for _, a := range application.Answers {
		var points int

		aq := &models.ApplicationToQuestion{
			StudentID:  int32(application.UserID),
			EventID:    int32(application.EventID),
			QuestionID: int32(a.QuestionID),
		}

		if a.AnswerID != nil {
			aq.AnswerID = int32(*a.AnswerID)
			if err := r.DB.NewSelect().
				Model((*models.Answer)(nil)).
				Column("points").
				Where("id = ?", *a.AnswerID).
				Scan(ctx, &points); err != nil {
				return nil, err
			}
		} else {
			p, err := strconv.Atoi(*a.Value)
			if err != nil {
				return nil, fmt.Errorf("when no answer id provided, value must be a number")
			}

			aq.Value = *a.Value
			points = p
		}

		aqs = append(aqs, *aq)

		score += points
	}

	a := &models.Application{
		EventID:   int32(application.EventID),
		StudentID: int32(application.UserID),
		Score:     int16(score),
	}

	if _, err := r.DB.NewInsert().
		Model(a).
		Exec(ctx); err != nil {
		return nil, err
	}

	if _, err := r.DB.NewInsert().
		Model(&aqs).
		Exec(ctx); err != nil {
		return nil, err
	}

	user, err := r.Query().Users(ctx, []int{int(application.UserID)}, nil)
	if err != nil {
		return nil, err
	}

	return user[0], nil
}

// DeleteStudentApplicationForEvent is the resolver for the deleteStudentApplicationForEvent field.
func (r *mutationResolver) DeleteStudentApplicationForEvent(ctx context.Context, studentID int, eventID int) (*models.User, error) {
	if _, err := r.DB.NewDelete().
		Model((*models.Application)(nil)).
		Where("student_id = ?", studentID).
		Where("event_id = ?", eventID).
		Exec(ctx); err != nil {
		return nil, err
	}

	user, err := r.Query().Users(ctx, []int{studentID}, nil)
	if err != nil {
		return nil, err
	}

	return user[0], nil
}

// LinkSupportingEventToEvent is the resolver for the linkSupportingEventToEvent field.
func (r *mutationResolver) LinkSupportingEventToEvent(ctx context.Context, eventID int, supportingEventID []int) (int, error) {
	if slices.Contains(supportingEventID, eventID) {
		return 0, fmt.Errorf("event cannot support itself")
	}

	var umbrelleIDs []int32
	if err := r.DB.NewSelect().
		Model((*models.Event)(nil)).
		Column("umbrella_id").
		Where("umbrella_id IS NOT NULL").
		Where("id IN (?)", bun.In(append(supportingEventID, eventID))).
		Scan(ctx, &umbrelleIDs); err != nil {
		return 0, err
	}

	if len(umbrelleIDs) != 0 {
		return 0, fmt.Errorf("both events have to be umbrella events")
	}

	var links []models.EventToSupportingEvent
	for _, sID := range supportingEventID {
		links = append(links, models.EventToSupportingEvent{EventID: int32(eventID), SupportingEventID: int32(sID)})
	}

	if _, err := r.DB.NewInsert().
		Model(&links).
		Exec(ctx); err != nil {
		return 0, err
	}

	return eventID, nil
}

// UnlinkSupportingEventFromEvent is the resolver for the unlinkSupportingEventFromEvent field.
func (r *mutationResolver) UnlinkSupportingEventFromEvent(ctx context.Context, eventID int, supportingEventID []int) (int, error) {
	var links []int32
	for _, id := range supportingEventID {
		links = append(links, int32(id))
	}

	if _, err := r.DB.NewDelete().
		Model((*models.EventToSupportingEvent)(nil)).
		Where("event_id = ?", eventID).
		Where("supporting_event_id IN (?)", bun.In(links)).
		Exec(ctx); err != nil {
		return 0, err
	}

	return eventID, nil
}

// AcceptTopApplicationsOnEvent is the resolver for the acceptTopApplicationsOnEvent field.
func (r *mutationResolver) AcceptTopApplicationsOnEvent(ctx context.Context, eventID int, count int) (int, error) {
	var applications []models.Application
	if err := r.DB.NewSelect().
		Model(&applications).
		Relation("Student").
		Where("event_id = ?", eventID).
		Where("accepted = false").
		Order("score ASC").
		Limit(count).
		Scan(ctx); err != nil {
		return 0, err
	}

	event := new(models.Event)
	if err := r.DB.NewSelect().Model(event).Where("id = ?", eventID).Scan(ctx); err != nil {
		return 0, err
	}

	for i, _ := range applications {
		applications[i].Accepted = utils.BoolPtr(true)
	}
	if _, err := r.DB.NewUpdate().
		Model(&applications).
		Column("accepted").
		Bulk().
		Exec(ctx); err != nil {
		return 0, err
	}

	m := r.MailConfig.ApplicationAccepted

	m.Actions[0].Button.Link = fmt.Sprintf("%s/%s-%s",
		os.Getenv("PUBLIC_URL"), slug.Make(event.Title), eventID)
	m.Actions[0].Button.Text = event.Title

	for _, a := range applications {
		if err := email.Send(*a.Student, m, r.MailConfig); err != nil {
			log.Error("failed to send email: ", err)
		}
	}

	return len(applications), nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, id []int, umbrellaID []int, topicID []int, typeID []int, needsTutors *bool, onlyFuture *bool, userID []int, includeSupportingEvents *bool) ([]*models.Event, error) {
	var events []*models.Event

	query := r.DB.NewSelect().
		Model(&events).
		Relation("Topic").
		Relation("Type").
		Relation("TutorsAvailable").
		Relation("Umbrella").
		Relation("Umbrella.RegistrationForm").
		Relation("Tutorials").
		Relation("Tutorials.Room").
		Relation("Tutorials.Room.Building").
		Relation("Tutorials.Tutors").
		Where(`"e"."umbrella_id" IS NOT NULL`).
		Order("e.from ASC")

	if umbrellaID != nil {
		query = query.Where(`"e"."umbrella_id" IN (?)`, bun.In(umbrellaID))
	}

	if typeID != nil {
		query = query.Where(`"e"."type_id" IN (?)`, bun.In(typeID))
	}

	if topicID != nil {
		query = query.Where(`"e"."topic_id" IN (?)`, bun.In(topicID))
	}

	if needsTutors != nil {
		query = query.Where(`"e"."needs_tutors" = ?`, *needsTutors)
	}

	if id != nil {
		query = query.Where(`"e"."id" IN (?)`, bun.In(id))
	}

	if onlyFuture != nil && *onlyFuture == true {
		query = query.Where(`"umbrella"."to" >= ?`, time.Now())
	}

	if userID != nil {
		query = query.
			Join("JOIN event_to_user_assignments AS eta ON eta.event_id = e.id").
			Join("LEFT JOIN user_to_event_availability AS uea ON uea.event_id = e.id").
			Where("uea.tutor_id IN (?) OR eta.tutor_id IN (?)", bun.In(userID), bun.In(userID))
	}

	if includeSupportingEvents != nil && *includeSupportingEvents == true && umbrellaID != nil {
		subq := r.DB.NewSelect().
			Model((*models.EventToSupportingEvent)(nil)).
			Where("event_id IN (?)", bun.In(umbrellaID)).
			Column("supporting_event_id")

		query = query.
			WhereOr("e.umbrella_id IN (?)", subq)
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return events, nil
}

// Umbrellas is the resolver for the umbrellas field.
func (r *queryResolver) Umbrellas(ctx context.Context, id []int, onlyFuture *bool) ([]*models.Event, error) {
	var umbrellas []*models.Event
	query := r.DB.NewSelect().
		Model(&umbrellas).
		Relation("Topic").
		Relation("RegistrationForm").
		Relation("SupportingEvents").
		Where("umbrella_id IS NULL").
		Order("from ASC")

	if id != nil {
		query = query.Where("e.id IN (?)", bun.In(id))
	}

	if onlyFuture != nil && *onlyFuture == true {
		query = query.Where(`"to" >= ?`, time.Now())
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return umbrellas, nil
}

// Buildings is the resolver for the buildings field.
func (r *queryResolver) Buildings(ctx context.Context, id []int) ([]*models.Building, error) {
	var buildings []*models.Building

	query := r.DB.NewSelect().
		Model(&buildings).
		Relation("Rooms")

	if id != nil {
		query = query.Where("id IN (?)", bun.In(id))
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return buildings, nil
}

// Rooms is the resolver for the rooms field.
func (r *queryResolver) Rooms(ctx context.Context, number []string, buildingID []int) ([]*models.Room, error) {
	var rooms []*models.Room

	query := r.DB.NewSelect().
		Model(&rooms).
		Relation("Building")

	if buildingID != nil {
		query = query.Where("building_id IN (?)", bun.In(buildingID))
	}

	if number != nil {
		query = query.Where("r.number IN (?)", bun.In(number))
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return rooms, nil
}

// Labels is the resolver for the labels field.
func (r *queryResolver) Labels(ctx context.Context, name []string, kind []model.LabelKind, umbrellaID []int) ([]*models.Label, error) {
	var labels []*models.Label

	query := r.DB.NewSelect().
		Model(&labels)

	if name != nil {
		query = query.Where("name IN (?)", bun.In(name))
	}

	if kind != nil {
		var kinds []string
		for _, k := range kind {
			kinds = append(kinds, k.String())
		}

		query = query.Where("kind IN (?)", bun.In(kinds))
	}

	if umbrellaID != nil {
		query = query.
			Where("EXISTS (SELECT 1 FROM events e WHERE e.umbrella_id IN (?) AND (e.topic_id = l.id OR e.type_id = l.id))",
				bun.In(umbrellaID))
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return labels, nil
}

// Settings is the resolver for the settings field.
func (r *queryResolver) Settings(ctx context.Context, key []string, typeArg []model.ScalarType) ([]*models.Setting, error) {
	var settings []*models.Setting

	query := r.DB.NewSelect().
		Model(&settings)

	if key != nil {
		query = query.Where("key IN (?)", bun.In(key))
	}

	if typeArg != nil {
		var types []string
		for _, t := range typeArg {
			types = append(types, t.String())
		}

		query = query.Where("type IN (?)", bun.In(types))
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return settings, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, id []int, mail []string) ([]*models.User, error) {
	var users []*models.User

	query := r.DB.NewSelect().
		Model(&users).
		Relation("Tutorials").
		Relation("Tutorials.Event").
		Relation("Tutorials.Room").
		Relation("Tutorials.Room.Building").
		Relation("Registrations").
		Relation("Registrations.Event").
		Relation("Registrations.Room").
		Relation("Registrations.Room.Building").
		Relation("Applications").
		Relation("Applications.Student").
		Relation("Applications.Event").
		Relation("Availabilities")

	if id != nil {
		query = query.
			Where("id IN (?)", bun.In(id))
	}

	if mail != nil {
		query = query.
			Where("mail IN (?)", bun.In(mail)).
			WhereOr("session_id IN (?)", bun.In(mail))
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return users, nil
}

// Forms is the resolver for the forms field.
func (r *queryResolver) Forms(ctx context.Context, id []int) ([]*models.Form, error) {
	var forms []*models.Form

	query := r.DB.NewSelect().
		Model(&forms).
		Relation("Questions").
		Relation("Questions.Answers")

	if id != nil {
		query = query.Where("event_id IN (?)", bun.In(id))
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return forms, nil
}

// Applications is the resolver for the applications field.
func (r *queryResolver) Applications(ctx context.Context, eventID *int, mail []string) ([]*models.Application, error) {
	var applications []*models.Application

	query := r.DB.NewSelect().
		Model(&applications).
		Relation("Event").
		Relation("Student").
		Relation("Form")

	if eventID != nil {
		query = query.Where("event_id = ?", *eventID)
	}

	if len(mail) > 0 {
		query = query.Where("student_id IN (?)", bun.In(mail))
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return applications, nil
}

// Tutorials is the resolver for the tutorials field.
func (r *queryResolver) Tutorials(ctx context.Context, id []int, eventID []int, umbrellaID []int, tutorID []int, studentID []int) ([]*models.Tutorial, error) {
	var tutorials []*models.Tutorial
	query := r.DB.NewSelect().
		Model(&tutorials).
		Relation("Event").
		Relation("Room").
		Relation("Room.Building").
		Relation("Tutors")

	if id != nil {
		query = query.Where("t.id IN (?)", bun.In(id))
	}

	if eventID != nil {
		query = query.Where("event_id IN (?)", bun.In(eventID))
	}

	if studentID != nil {
		query = query.
			Join(`JOIN "user_to_tutorial_registrations" AS "utr" ON "t"."user_id" = "utr"."user_id" AND "t"."id" = "utr"."tutorial_id"`).
			Where(`"t"."user_id" IN (?)`, bun.In(studentID))
	}

	if tutorID != nil {
		query = query.
			Join("JOIN tutorial_to_user_assignments AS tua ON t.id = tua.tutorial_id").
			Where("user_id IN (?)", bun.In(tutorID))
	}

	if err := query.Scan(ctx); err != nil {
		return nil, err
	}

	return tutorials, nil
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, mail string, password string) (string, error) {
	user := new(models.User)
	if err := r.DB.NewSelect().
		Model(user).
		Where("mail = ?", mail).
		Scan(ctx); err != nil {
		return "", err
	}

	if err := auth.VerifyPepperedHash(user.Password, password); err != nil {
		log.Printf("failed login attempt for: %v", mail)
		return "", err
	}

	if user.SessionID == "" {
		sid, err := auth.GenerateSessionID()
		if err != nil {
			return "", fmt.Errorf("error while generating sessionID for %s: %s", user.Mail, err)
		}
		user.SessionID = sid
	}

	user.LastLogin = time.Now()

	if _, err := r.DB.NewUpdate().
		Model(user).
		Where("mail = ?", mail).
		Exec(ctx); err != nil {
		return "", err
	}

	return user.SessionID, nil
}

// Type is the resolver for the type field.
func (r *questionResolver) Type(ctx context.Context, obj *models.Question) (model.QuestionType, error) {
	for _, t := range model.AllQuestionType {
		if t.String() == obj.Type {
			return t, nil
		}
	}

	return model.QuestionTypeText, fmt.Errorf("%s is not a valid question type", obj.Type)
}

// Capacity is the resolver for the capacity field.
func (r *roomResolver) Capacity(ctx context.Context, obj *models.Room) (*int, error) {
	capacity := int(obj.Capacity)
	return &capacity, nil
}

// Floor is the resolver for the floor field.
func (r *roomResolver) Floor(ctx context.Context, obj *models.Room) (*int, error) {
	floor := int(obj.Floor)
	return &floor, nil
}

// Type is the resolver for the type field.
func (r *settingResolver) Type(ctx context.Context, obj *models.Setting) (model.ScalarType, error) {
	for _, t := range model.AllScalarType {
		if t.String() == obj.Type {
			return t, nil
		}
	}

	return model.ScalarTypeString, fmt.Errorf("unable to resolve type: %s", obj.Type)
}

// RegistrationCount is the resolver for the registrationCount field.
func (r *tutorialResolver) RegistrationCount(ctx context.Context, obj *models.Tutorial) (int, error) {
	count, err := r.DB.NewSelect().
		Model((*models.UserToTutorialRegistration)(nil)).
		Where("tutorial_id = ?", obj.ID).
		Count(ctx)
	if err != nil {
		return 0, err
	}

	return count, nil
}

// Students is the resolver for the students field.
func (r *tutorialResolver) Students(ctx context.Context, obj *models.Tutorial) ([]*models.User, error) {
	var registrations []*models.UserToTutorialRegistration
	if err := r.DB.NewSelect().
		Model(&registrations).
		Relation("User").
		Where("tutorial_id = ?", obj.ID).
		Scan(ctx); err != nil {
		return nil, err
	}

	var users []*models.User
	for _, registration := range registrations {
		users = append(users, registration.User)
	}

	return users, nil
}

// Role is the resolver for the role field.
func (r *userResolver) Role(ctx context.Context, obj *models.User) (model.Role, error) {
	return model.Role(obj.Role), nil
}

// Points is the resolver for the points field.
func (r *newAnswerResolver) Points(ctx context.Context, obj *models.Answer, data int) error {
	obj.Points = int8(data)
	return nil
}

// Kind is the resolver for the kind field.
func (r *newLabelResolver) Kind(ctx context.Context, obj *models.Label, data model.LabelKind) error {
	obj.Kind = data.String()
	return nil
}

// Type is the resolver for the type field.
func (r *newQuestionResolver) Type(ctx context.Context, obj *models.Question, data model.QuestionType) error {
	obj.Type = data.String()
	return nil
}

// Capacity is the resolver for the capacity field.
func (r *newRoomResolver) Capacity(ctx context.Context, obj *models.Room, data int) error {
	obj.Capacity = int16(data)
	return nil
}

// Floor is the resolver for the floor field.
func (r *newRoomResolver) Floor(ctx context.Context, obj *models.Room, data *int) error {
	obj.Floor = int8(*data)
	return nil
}

// Type is the resolver for the type field.
func (r *newSettingResolver) Type(ctx context.Context, obj *models.Setting, data *model.ScalarType) error {
	obj.Type = data.String()
	return nil
}

// Answer returns AnswerResolver implementation.
func (r *Resolver) Answer() AnswerResolver { return &answerResolver{r} }

// Application returns ApplicationResolver implementation.
func (r *Resolver) Application() ApplicationResolver { return &applicationResolver{r} }

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

// Label returns LabelResolver implementation.
func (r *Resolver) Label() LabelResolver { return &labelResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Question returns QuestionResolver implementation.
func (r *Resolver) Question() QuestionResolver { return &questionResolver{r} }

// Room returns RoomResolver implementation.
func (r *Resolver) Room() RoomResolver { return &roomResolver{r} }

// Setting returns SettingResolver implementation.
func (r *Resolver) Setting() SettingResolver { return &settingResolver{r} }

// Tutorial returns TutorialResolver implementation.
func (r *Resolver) Tutorial() TutorialResolver { return &tutorialResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// NewAnswer returns NewAnswerResolver implementation.
func (r *Resolver) NewAnswer() NewAnswerResolver { return &newAnswerResolver{r} }

// NewLabel returns NewLabelResolver implementation.
func (r *Resolver) NewLabel() NewLabelResolver { return &newLabelResolver{r} }

// NewQuestion returns NewQuestionResolver implementation.
func (r *Resolver) NewQuestion() NewQuestionResolver { return &newQuestionResolver{r} }

// NewRoom returns NewRoomResolver implementation.
func (r *Resolver) NewRoom() NewRoomResolver { return &newRoomResolver{r} }

// NewSetting returns NewSettingResolver implementation.
func (r *Resolver) NewSetting() NewSettingResolver { return &newSettingResolver{r} }

type answerResolver struct{ *Resolver }
type applicationResolver struct{ *Resolver }
type eventResolver struct{ *Resolver }
type labelResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type questionResolver struct{ *Resolver }
type roomResolver struct{ *Resolver }
type settingResolver struct{ *Resolver }
type tutorialResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type newAnswerResolver struct{ *Resolver }
type newLabelResolver struct{ *Resolver }
type newQuestionResolver struct{ *Resolver }
type newRoomResolver struct{ *Resolver }
type newSettingResolver struct{ *Resolver }
